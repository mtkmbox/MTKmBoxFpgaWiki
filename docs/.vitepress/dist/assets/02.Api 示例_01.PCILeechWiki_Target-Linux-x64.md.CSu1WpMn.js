import{_ as t,c as a,a2 as i,o as r}from"./chunks/framework.BDQf3LYc.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"02.Api 示例/01.PCILeechWiki/Target-Linux-x64.md","filePath":"02.Api 示例/01.PCILeechWiki/Target-Linux-x64.md"}'),n={name:"02.Api 示例/01.PCILeechWiki/Target-Linux-x64.md"};function o(l,e,s,d,h,u){return r(),a("div",null,e[0]||(e[0]=[i('<h2 id="target-operating-system-linux-64-bit-x64" tabindex="-1">Target operating system: Linux 64-bit (x64) <a class="header-anchor" href="#target-operating-system-linux-64-bit-x64" aria-label="Permalink to &quot;Target operating system: Linux 64-bit (x64)&quot;">​</a></h2><p>PCILeech is currently able to target Linux x64 with kernel module implants. PCILeech does not support 32-bit Linux targets or ARM targets, except for native DMA memory access which is operating system independent.</p><p>The Linux kernel have gone through several changes during the years and different signatures and methods are required depending on the target system kernel version and the attack hardware used.</p><p>In kernels equal or below version 4.6 the kernel itself is always found below 4GB which means that both the USB3380 and FPGA hardware is able to access the kernel and patch into it.</p><p>Kernels equal to or above version 4.8 randomizes the kernel in the whole physical memory, making it unlikely to end up below 4GB which makes it a problem for USB3380 hardware - but not for FPGA hardware.</p><p>Kernels above or equal to 4.19 may currently experience problems.</p><p>In addition to directly target the kernel PCILeech supports targeting the EFI Runtime Services. This may be useful if USB3380 attack hardware is used more recent kernels and the system is EFI booted and not Legacy/MBR booted. The EFI Runtime Services attack method is discussed more in detail in the blog entry <a href="http://blog.frizk.net/2017/01/attacking-uefi-and-linux.html" target="_blank" rel="noreferrer">Attacking UEFI Runtime Services and Linux</a>.</p><hr><h3 id="examples" tabindex="-1">Examples: <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;Examples:&quot;">​</a></h3><p>Load a kernel module into Linux kernel 4.6 or below. Minimum supported kernel version 2.6.33. Both USB3380 and FPGA hardware.</p><ul><li><code>pcileech kmdload -kmd LINUX_X64_46</code></li></ul><p>Load a kernel module into the Linux kernel by first targeting the EFI runtime services. Both USB3380 and FPGA hardware.</p><ul><li><code>pcileech kmdload -kmd LINUX_X64_EFI</code></li></ul><p>Load a kernel module into Linux kernel 4.8 or above. Not likely to work with USB3380 hardware unless extremely lucky, will work with FPGA hardware.</p><ul><li><code>pcileech kmdload -kmd LINUX_X64_48</code></li></ul><p>Mount Linux, kernel prior or equal to 4.6, target system live RAM and file system without pre-loading a KMD.</p><ul><li><code>pcileech.exe mount -kmd LINUX_X64_46</code></li></ul><p>Retrieve the file /etc/shadow from a Linux system without pre-loading a KMD.</p><ul><li><code>pcileech lx64_filepull -kmd LINUX_X64_46 -s /etc/shadow -out c:\\temp\\shadow</code></li></ul><p>In addition to the examples below please find additional built-in commands and Linux compatible implants starting with lx64 when executing <code>pcileech</code> without any parameters.</p>',20)]))}const m=t(n,[["render",o]]);export{p as __pageData,m as default};
